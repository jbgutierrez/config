" General settings{{{
" load pathogen managed plugins{{{
" To disable a plugin, add it's bundle name to the following list
let g:pathogen_disabled = []
if !has('gui_running')
  call add(g:pathogen_disabled, "vim-css-color")
endif
call pathogen#infect()"}}}
" general configuration {{{
set nocompatible        " Use Vim defaults (much better!)
set backspace=indent,eol,start " allow backspacing over everything in insert mode
set virtualedit=all     "allows the cursor to freely roam anywhere it likes in command mode
set viminfo='20,\"50    " read/write a .viminfo file, don't store more
                        " than 50 lines of registers
set history=1000        " keep 50 lines of command line history
set ruler               " show the cursor position all the time
set nonumber            " hide line numbers
set scrolloff=3         " leave 3 lines of breathing room
set title               " show title
set hidden              " allows changing of buffers without saving
set lazyredraw          " Set lazydraws so that rendering is much faster during macros
set showmode            " I like to know which mode I am in at times
set showcmd             " show the command being typed
set showmatch           " show matching brackets
set list                " show whitespace
set listchars=tab:▸\ ,eol:¬,trail:.  "use the same symbols as TextMate for tabstops and EOLs
set hidden
set statusline=%F%m%r%h%w[%L]%y[%p%%][%04l,%04v]%=[%{&ff},%{\"\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").\"]\ \"} "[%{fugitive#statusline()}]
"              | | | | |  |   |  |       |    |
"              | | | | |  |   |  |       |    + current column
"              | | | | |  |   |  |       +-- current line
"              | | | | |  |   |  +-- current % into file
"              | | | | |  |   +-- current syntax in square brackets
"              | | | | |  +-- number of lines
"              | | | | +-- preview flag in square brackets
"              | | | +-- help flag in square brackets
"              | | +-- readonly flag in square brackets
"              | +-- rodified flag in square brackets
"              +-- full path to file in the rbuffer
"}


set nrformats=            " make CTRL-A and CTRL-X commands work exclusively with decimals
set laststatus=2          " always show the last status
set wildignore+=*.xls,*.doc,*.cd,*.dll,*.o,*.obj,*.bak,*.exe,*.pyc,*.jpg,*.gif,*.png
set wildmode=list:longest " turn on wild mode huge list
set wildmenu              " turn on command line completion wild style"}}}
" tabs and indentation{{{
set tabstop=2
set softtabstop=2
set shiftwidth=2
set smartindent    " use smart indentation over autoindent
set smarttab       " smart tabulatin and backspace
set expandtab      " To spaces to tabs 'set noexpandtab' and ':retab!'
"}}}
" search{{{
set gdefault           " global search/replace by default
" clear the search buffer when hitting return {{{
nnoremap <cr> :set hlsearch! hlsearch?<cr>
nnoremap <leader><leader> <c-^>"}}}
set incsearch hlsearch " highlight matches as you type
set smartcase          " override ignorecase when there are uppercase characters
set ignorecase         " ignore case when searching "}}}
" wraping{{{
set nowrap                   " don't wrap lines
set listchars+=extends:»     " show a » when a line goes off the right edge of the screen
set listchars+=precedes:«    " show a « when a line goes off the left edge of the screen
set linebreak                " when wrapping, try to break at characters in breakat
set breakat=\ ^I!@*-+;:,./?  " when wrapping, break at these characters
set showbreak=>              " character to show that a line is wrapped"}}}
" encoding and fileformat{{{
set enc=utf-8 nobomb
" set enc=iso-8859-1"}}}
" spell checking{{{
set spell spelllang=en " Z= to show suggestions
set spellsuggest=5"}}}
" file backups{{{
set nobackup                                        " Don't make a backup before overwriting a file.
set nowritebackup                                   " And again.
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp " Store temporary files in a central spot
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp"}}}
" UI settings{{{

"improve autocomplete menu color
"gui options
set guifont=Monaco:h12.00
set guioptions-=T
set guioptions-=r
set guioptions-=R
set guioptions-=l
set guioptions-=R
au! ColorScheme * hi Pmenu ctermbg=238 gui=bold
" au ColorScheme * hi Folded guibg=#292421
au ColorScheme * hi IncSearch gui=underline guifg=NONE guibg=NONE ctermfg=NONE ctermbg=NONE term=underline cterm=underline
au ColorScheme * hi Search gui=underline guifg=NONE guibg=NONE ctermfg=NONE ctermbg=NONE term=underline cterm=underline
" colorscheme sunburst
"Invisible character colors

if has("gui_running")
  set cursorline " highlight current line
  set cursorcolumn
else
  set nospell
endif
set clipboard+=unnamed "accessing the system clipboard"}}}
" mswin settings{{{
if has('win32') || has ('win64')
  so $VIMRUNTIME/mswin.vim
  behave mswin
  set ffs=dos
  let $VIMHOME='~/vimfiles'
else
  let $VIMHOME='~/.vim'
endif"}}}"}}}

" Coding settings{{{
" general{{{
syntax on             " Enable syntax highlighting
filetype on           " Enable filetype detection
filetype indent on    " Enable filetype-specific indenting
filetype plugin on    " Enable filetype-specific plugins
compiler ruby         " Enable compiler support for ruby
" Auto save folds
" au BufWinLeave * mkview
" au BufWinEnter * silent loadview"}}}
" spaces, tabs and DOS text files{{{
" au BufRead * silent! %s//\r/g  " never see ^M again! (DOS text files, <c-v> <c-m> )
" au BufWrite * silent! %s/\v\s+$// " chop off unnecesary tabs and spaces"}}}
" folding{{{
set foldlevel=1
set foldmethod=syntax
set fillchars=fold:\ "
set foldtext=MyFoldText() " Custom fold text function

if has("ruby")
  set ballooneval
endif
"}}}
" .vimrc{{{
au! BufWritePost $MYVIMRC source % " When vimrc is edited, reload it
au BufRead,BufWritePost $MYVIMRC set foldmethod=marker "}}}
" ruby{{{
au FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
au FileType ruby,eruby let g:rubycomplete_rails = 1
au FileType ruby,eruby let g:rubycomplete_classes_in_global = 1"}}}
" XML{{{
au FileType xml exe ":silent 1,$!xmllint --format --recover - 2>/dev/null"
let g:xml_syntax_folding=1"}}}
" Java{{{
au! FileType java setlocal foldmethod=syntax"}}}
" haml{{{
au! BufRead,BufNewFile *.haml setfiletype haml"}}}
" css{{{
au! FileType css setlocal foldmethod=marker
au FileType css setlocal foldmarker={,} "}}}
" csharp{{{
au! FileType cs call CSharp()"}}}
" diff{{{
au! FileType diff setlocal fdm=expr
au FileType diff setlocal fde=DiffFoldLevel()
au FileType diff setlocal fdc=1
au FileType diff setlocal foldlevel=0
au BufReadPost {COMMIT_EDITMSG,*/COMMIT_EDITMSG} set ft=diff"}}}
" coffescript{{{
let coffee_compile_on_save = 1
" au BufWritePost *.coffee silent CoffeeCompile -b | cwindow | redraw!
au! BufWritePost,FileWritePost *.coffee :silent !coffee -c <afile>
au BufNewFile,BufReadPost *.coffee setl foldmethod=indent nofoldenable
":[RANGE] CoffeeCompile [watch|unwatch] [vert[ical]] [WINDOW-SIZE]
"}}}
" file types really do require explicit tabs, and not spaces{{{
au! FileType make   setlocal noexpandtab
au! FileType python setlocal noexpandtab"}}}
" load templates{{{
au BufNewFile * silent! 0r $VIMHOME/personal/%:e.tpl"}}}
" guess indent from buffer {{{
let g:detectindent_preferred_indent=2
au BufReadPost * :DetectIndent "}}}
" jumps to the last known position in a file just after opening it, if the '" mark is set: > {{{
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif "}}}
" open a split for each dirty file in git {{{
function! OpenChangedFiles()
  only " Close all windows, unless they're modified
  let status = system('git status -s | grep "^ \?\(M\|A\|UU\)" | sed "s/^.\{3\}//"')
  let filenames = split(status, "\n")
  exec "edit " . filenames[0]
  for filename in filenames[1:]
    exec "sp " . filename
  endfor
endfunction
command! OpenChangedFiles :call OpenChangedFiles()"}}}
" resize stacked windows {{{
nnoremap <C-W>j <C-W>j<C-W>_
nnoremap <C-W>k <C-W>k<C-W>_
nnoremap <C-W>l <C-W>l<C-W>_
nnoremap <C-W>h <C-W>h<C-W>_
set winheight=4
set winminheight=4"}}}
" strip trailing whitespace {{{
function! <SID>StripTrailingWhitespaces()
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Do the business:
  %s/\s\+$//e
  " Clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction
autocmd BufWritePre * :call <SID>StripTrailingWhitespaces()"}}}
" show extra whitespace as error {{{
highlight ExtraWhitespace ctermbg=red guibg=red
augroup WhitespaceMatch
  " Remove ALL autocommands for the WhitespaceMatch group.
  autocmd!
  autocmd BufWinEnter * let w:whitespace_match_number =
        \ matchadd('ExtraWhitespace', '\s\+$')
  autocmd InsertEnter * call s:ToggleWhitespaceMatch('i')
  autocmd InsertLeave * call s:ToggleWhitespaceMatch('n')
augroup END

function! s:ToggleWhitespaceMatch(mode)
  let pattern = (a:mode == 'i') ? '\s\+\%#\@<!$' : '\s\+$'
  if exists('w:whitespace_match_number')
    call matchdelete(w:whitespace_match_number)
    call matchadd('ExtraWhitespace', pattern, 10, w:whitespace_match_number)
  else
    " Something went wrong, try to be graceful.
    let w:whitespace_match_number =  matchadd('ExtraWhitespace', pattern)
  endif
endfunction"}}}"}}}

" Key mappings{{{
" general{{{
let mapleader = ","
nmap <s-u> :redo<CR>           " redo
nmap <leader>l :set list!<CR> " shortcut to rapidly toggle `set list` (retab! if neccesary)
map <leader>e :e $MYVIMRC<cr>   " fast editing of the .vimrc"}}}
" can't be bothered to understand ESC vs <c-c> in insert mode {{{
imap <c-c> <esc>
"}}}
" moving around split windows{{{
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l"}}}
" function keys{{{
map <F2> :TlistToggle<CR>                               " F2 - List methods
map <S-F2> :!/usr/local/bin/ctags -R .<CR>
map <F4> :set hlsearch! hlsearch?<CR>                   " F4 - highlighting on/off
map <F5> :GundoToggle<cr>                               " F5 - Toggle Gundo bufferbuffer
map <F6> :call ToggleScratch()<CR>                      " F6 - Toggle scratch buffer
set textwidth=80
nmap <F10> gqap                                         " F10 - Format paragraph
imap <F11> <ESC>1G=Ga                                   " F11 - Format code
nnoremap <F11> :call CleanFile()<CR>                    " delete empty lines "}}}
" change working directory{{{
nmap <silent>cd :cd %:p:h<CR>:pwd<CR>
nmap <silent>lcd :lcd %:p:h<CR>:pwd<CR>"}}}
" easy Expansion of the Active File Directory{{{
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'"}}}
" move text around{{{
nmap <S-Tab> <C-o>
" nmap <Tab> >>
vmap <S-Tab> <gv
vmap <Tab> >gv
nmap <C-j> :m+<CR>==
nmap <C-k> :m-2<CR>==
" imap <C-j> <Esc>:m+<CR>==gi
" imap <C-k> <Esc>:m-2<CR>==gi
vmap <C-j> :m'>+<CR>gv=gv
vmap <C-k> :m-2<CR>gv=gv"}}}
" i18n translations {{{
vmap t s'gvs)i= t<esc>
nmap t cs"'vi'lohs)it<esc>
" nmap t ds"ds'viws'gvs)it<esc>"}}}
" shortcuts for rails commands{{{
" map <leader>m :rmodel
" map <leader>c :rcontroller
" map <leader>v :rview
" map <leader>u :runittest
" map <leader>f :rfunctionaltest
" map <leader>tm :rtmodel
" map <leader>tc :rtcontroller
" map <leader>tv :rtview
" map <leader>tu :rtunittest
" map <leader>tf :rtfunctionaltest
" map <leader>sm :rsmodel
" map <leader>sc :rscontroller
" map <leader>sv :rsview
" map <leader>su :rsunittest
" map <leader>sf :rsfunctionaltest"}}}
" folding{{{
nnoremap <space> za    " space - toggle current fold
nnoremap <s-space> @=((foldclosed('.') == -1) ? 'za' : 'zA')<CR> " space - toggle current fold"}}}
" rename current file {{{
map <leader>t :CommandT<cr>
map <leader>tt :CommandTFlush<cr>\|:CommandT<cr>
"}}}
" coding utilities{{{
map <d-r> <plug>rubyfilerun    " run file in shell mode with ruby
map <leader>m ggO# coding: UTF-8<esc>
map <leader>r ggO#!/usr/bin/env ruby<esc>
nmap <leader>a\| :Tab /\|<CR>
vmap <leader>a\| :Tab /\|<CR>
nmap <Leader>a= :Tab /=<CR>
vmap <Leader>a= :Tab /=<CR>
nmap <Leader>a: :Tab /:\zs<CR>
vmap <Leader>a: :Tab /:\zs<CR>
" Insert a hash rocket with <c-l>
imap <c-l> <space>=><space>
map <leader>c gcc              " toggle comment "}}}
" rotating among results in an ack search{{{
map <C-n> :cn<CR>
map <C-p> :cp<CR>"}}}
" replace selected text{{{
" nmap <c-r> yiw:%s/<c-r>"//gc<left><left><left>
vmap <c-r> y:%s/<c-r>"//gc<left><left><left>
nmap s "_diw"0P
" vmap s "_d"0P"}}}
" search{{{
" nmap <leader>a :Ack
" nmap + yiw:Ack <c-r>"
"}}}
" switch between buffers{{{
nmap <A-tab> :bn<CR>
nmap <A-S-tab> :bp<CR>
nmap <leader>d :bd<CR>
nmap <leader>D :bufdo bd<CR>"}}}
" move between splits{{{
noremap <A-H> <C-w>h
noremap <A-J> <C-w>j
noremap <A-K> <C-w>k
noremap <A-L> <C-w>l"}}}
" rename file {{{
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
map <leader>n :call RenameFile()<cr>
"}}}
" save file{{{
map <C-s> :w<cr>
map <C-S-s> :browse confirm saveas<cr>"}}}
" make search results appear in the middle of the screen{{{
nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz"}}}"}}}

" plugins settings{{{
" Tag List{{{
let Tlist_Show_Menu=1
let Tlist_GainFocus_On_ToggleOpen = 1      " Focus on the taglist when its toggled
let Tlist_Close_On_Select = 1              " Close when something's selected
let Tlist_Compact_Format=1
let Tlist_Ctags_Cmd = "/usr/local/bin/ctags"
let Tlist_Use_Right_Window = 1             " Project uses the left window
let Tlist_WinWidth = 50
" Language Specifics"{{{
    " just functions and classes please
    let tlist_aspjscript_settings = 'asp;f:function;c:class'
    " just functions and subs please
    let tlist_aspvbs_settings = 'asp;f:function;s:sub'
    " don't show variables in freaking php
    let tlist_php_settings = 'php;c:class;d:constant;f:function'
    " just functions and classes please
    let tlist_vb_settings = 'asp;f:function;c:class'"}}}
"}}}
" ToogleScratch{{{
function! ToggleScratch()
  if expand('%') == g:ScratchBufferName
    quit
  else
    Sscratch
  endif
endfunction"}}}
" Ack{{{
set grepprg=ack
set grepformat=%f:%l:%m"}}}
" JsBeautify {{{
autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>"}}}
" neocomplcache {{{
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Use camel case completion.
let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
let g:neocomplcache_enable_underbar_completion = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" " Plugin key-mappings.
" imap <C-k>     <Plug>(neocomplcache_snippets_expand)
" smap <C-k>     <Plug>(neocomplcache_snippets_expand)
" inoremap <expr><C-g>     neocomplcache#undo_completion()
" inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" " SuperTab like snippets behavior.
" imap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"
"
" " Recommended key-mappings.
" " <CR>: close popup and save indent.
" inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
" " <TAB>: completion.
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" " <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><C-y>  neocomplcache#close_popup()
" inoremap <expr><C-e>  neocomplcache#cancel_popup()

" AutoComplPop like behavior.
" let g:neocomplcache_enable_auto_select = 1

" Shell like behavior(not recommended).
set completeopt+=longest
let g:neocomplcache_enable_auto_select = 1
" let g:neocomplcache_disable_auto_complete = 1
" inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<TAB>"
" inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"

" Enable omni completion.
au FileType css setlocal omnifunc=csscomplete#CompleteCSS
au FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
au FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au FileType python setlocal omnifunc=pythoncomplete#Complete
au FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
au FileType ruby,eruby setlocal omnifunc=rubycomplete#Complete

" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'"}}}
" Fugitive {{{
autocmd BufReadPost fugitive://* set bufhidden=delete"}}}
" Command-T{{{
let g:CommandTMaxHeight=10"}}}"}}}

" finally, load local project configs {{{
if filereadable('.vimrc.local')
  source .vimrc.local
endif"}}}

" command! InsertTime :normal a<c-r>=strftime('%F %H:%M:%S.0 %z')<cr>
" find . -name "*.rb" | xargs file | grep "CRLF" | awk -F: '{print $1}' | xargs gvim
" bufdo set ff=unix | w
